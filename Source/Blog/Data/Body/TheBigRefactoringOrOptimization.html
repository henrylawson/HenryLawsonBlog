<p>Every now and then a team will find itself with an architecture that isn't quite right or a system that isn't performing quite as everyone would have hoped so. In these cases the inevitable happens - <strong>The Big Refactoring or Optimization</strong>. Now there is nothing wrong with this, evolving architectures and codebases are a fundamental part of agile software projects. What I'm sharing today are some insights that I gained while recently undertaking this journey with my team:</p>
<ul>
	<li>Having a high <a href="http://c2.com/cgi/wiki?UnitTest">unit test</a> <a href="http://henrylawson.net/the-magic-number">coverage</a> is a requirement <strong>but it isn't enough</strong></li>
	<li>Solid <a href="http://www.extremeprogramming.org/rules/functionaltests.html">acceptance and or functional tests</a> are a godsend</li>
</ul>
<p>The biggest learning from this exercise was that even though you might have a high unit level coverage (> 92%) things still manage to sneak through the cracks. <strong>While all those execution paths might be covered, they might not be tested that well</strong>. A good unit test is one that tests itself in isolation of others. The problem is that if those isolated unit tests aren't thoroughly testing things at their level, problems don't show themselves until a much higher level - <i>once everything is integrated</i>.</p>
<p>To put this point into context, we were doing optimizations around repository calls for entities from the database. The tests for the repository methods probably didn't cover as many scenarios as they should have. After the optimization the tests all passed, <i>the repository methods were still returning the same information that the tests were expecting</i>. The problem of course was that they <strong>weren't returning the exact information that they used too</strong>. This resulted in some hard to find bugs popping up on the UI layer that took some time to pin back down to those refactored repository methods.</p>
<p>This is where a good acceptance and or functional test suite can come in handy. I'm not saying that they should be some how testing the right data is coming in and out of the repository but a decent functional test suite will at least fail on one of the flows affected by the refactoring. An investigation into the failure would then lead to the discovery of fudged refactorings. Unfortunately in our case, we weren't doing <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> or <a href="http://www.methodsandtools.com/archive/archive.php?id=72">ATDD</a> and this refactoring was occurring before those tests existed. <i>It must also be noted that if a functional and or acceptance test does discover one of these bugs its more of a bonus, these cases 	really need to be covered at the unit level.</i></p>
<p>Another important learning was that these optimizations and refactorings should be done by someone who has a little bit of context on the area being worked on. This is because if those unit tests are sufficient, at least you are pairing with someone who has a bit of an idea of what that code used to be doing.</p>